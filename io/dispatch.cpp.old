#include <sstream>
#include <iomanip>
#include <poll.h>

#include "dispatch.h"
#include "tcpUtil.h"
#include "protocol.h"


void dispatch::manageQs()
{
    lookForNewClients();
    handleReads();
    if (taskQ.size() > 0) 
        handleWrites();
}

void dispatch::dispatchTask(task& newTask)
{
    taskQ.push(newTask);
}

void dispatch::lookForNewClients() 
{
    struct pollfd monFd[1];
    monFd[0].fd = servSock;
    monFd[0].events = readMask;

    if ((poll(monFd, 1, 0) == 1)) {
        struct sockaddr_in cliAddr;
        socklen_t cliAddrLen = sizeof(sockaddr_in);
        int cliSock;
        if ((cliSock = accept(servSock, (struct sockaddr *)&cliAddr,
                               &cliAddrLen)) > 0)  {
            clientList.insert({cliSock,{cliSock}});
        }
    }
}

void dispatch::handleReads()
{
    struct pollfd rdFd[16];
    uint16_t currIn = 0;
    for (auto mem:clientList) {
        if (mem.second.active == true) {
            rdFd[currIn].fd = mem.first;
            rdFd[currIn++].events = readMask;
        }
    }
    
    int rc = poll(rdFd, currIn, 0);
    if (rc <= 0)
        return;
    
    std::set<int> rdSet;
    for (uint32_t i = 0; i < currIn; i++)
        if (rdFd[i].revents & readMask) 
            rdSet.insert(rdFd[i].fd);

    const std::string logPrf = "Result: ";
    for (auto mem:rdSet) {
        struct result tR;
        if (protocol::readResult(mem, tR) == true) {
            resultQ.push(tR);
            logResult(logPrf + std::to_string(mem), tR);
            clientList.find(mem)->second.active = false;
            clientList.find(mem)->second.lastReply = time(0);
       } else {
           logSink->addEntry("Error! on client " + std::to_string(mem));
       }
    }
}

void dispatch::handleWrites()
{
    struct pollfd wrFd[16];
    uint16_t currIn = 0;
    for (auto mem:clientList) {
        if (mem.second.active == false)  {
            wrFd[currIn].fd = mem.first;
            wrFd[currIn++].events = writeMask;
        }
    }

    int rc = poll(wrFd, currIn, 0);
    if (rc <= 0)
        return;
    
    std::set<int> wrSet;
    for (uint32_t i = 0; i < currIn; i++)
        if (wrFd[i].revents & writeMask) 
            wrSet.insert(wrFd[i].fd);
    
    std::string logStr = "Task Dispatch";
    /*
    for (int32_t i = 0; i < clientList.size(); i++) {

        if (taskQ.size() == 0)
            break;
    */

    while (taskQ.size() != 0) {
        int cFd = getOldestClient();
        if (cFd == -1)
            break;

        if (wrSet.find(cFd) != wrSet.end()) {
            struct task t = taskQ.front();
            protocol::writeTask(cFd, t);
            clientList.find(cFd)->second.active = true;
            std::string cliStr = " " + std::to_string(cFd) + " ";
            logTask(logStr + cliStr, t);
            taskQ.pop();
        }
    }
}

bool dispatch::fetchResults(result& rc)
{
    if (resultQ.size() != 0) {
        rc = resultQ.front();
        resultQ.pop();
        return true;
    }
    return false;
}

void dispatch::terminate() 
{
    for (auto mem:clientList) {
        std::string tL = "client " + std::to_string(mem.first) + 
                         " " + "Finished";
        logSink->addEntry(tL);
        protocol::terminateClient(mem.first);
    }
}

void dispatch::logTask(const std::string& prefix, const struct task& tsk)
{
    std::string line = prefix + " " + tsk.id + " " + tsk.type;
    logSink->addEntry(line);
     
}

void dispatch::logResult(const std::string& prefix, 
                         const struct result& rslt)
{
    std::string line = prefix + " " + rslt.id + " RC " 
                       + std::to_string(rslt.rc);
    logSink->addEntry(line);
}

void dispatch::getNewTask(char tType, const strVec& tArgs, struct task& newTask)
{
    std::string tid;
    getTaskId(tid);

    newTask.type = tType;
    newTask.id = tid;
    newTask.args = tArgs;
}

void dispatch::getTaskId(std::string& id)
{
    std::stringstream ss;
    ss << std::setw(4) << std::setfill('0') << taskId;
    id = 'T' + ss.str();
    taskId++;
}


int dispatch::getOldestClient()
{
    if (clientList.size() == 0)
        return -1;

/*
    if ((clientList.size() == 1) && 
        (clientList.begin()->second.active == true))
        return clientList.begin()->first;
    else 
        return -1;
*/
    
    for(auto mem: clientList) {
        std::string line = "DC " + std::to_string(mem.first) + " " 
                           + std::to_string(mem.second.lastReply);
        std::string busy = (mem.second.active == true) ? " T ":" F ";
        logSink->addEntry(line + busy);
    }
         
    time_t oldestTime = time(0) * 2;
    int oldestCl = -1;
    for(auto mem: clientList) {
        if (mem.second.active == true)
            continue;
        if (mem.second.lastReply == 0) {
            oldestCl = mem.first;
            break;
        }

        if (oldestTime > mem.second.lastReply) {
            oldestTime = mem.second.lastReply;
            oldestCl = mem.first;
        }
    }
    
    logSink->addEntry("Next Client " + std::to_string(oldestCl));
    return oldestCl;
}
